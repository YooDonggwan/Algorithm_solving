## 알고리즘 풀이 피드백



- 백준 11053 - 가장 긴 증가하는 부분 수열
  - <img src="/Users/YooDongGwan/Library/Application Support/typora-user-images/스크린샷 2021-02-21 오후 7.01.23.png" alt="스크린샷 2021-02-21 오후 7.01.23" style="zoom: 33%;" />
  -  바보같이 생각한 첫 풀이 
    - 1. 수열인데 정렬을 새로해서 풀려고 했다. - 그냥 멍청한 생각
      2. dp배열에 첫 번째 원소를 넣고 실행했다 - 안 되는 이유는 첫 번째 원소에 큰 숫자가 들어가면 길이는 2 이상으로 갈 수 없다.
  - 수정한 풀이
    - 현재 인덱스 이 전에 나보다 작은 수는 몇 개인지를 따져보면 될 것같다는 생각을 함
  - 구체적 풀이
    - <img src="/Users/YooDongGwan/Library/Application Support/typora-user-images/스크린샷 2021-02-21 오후 8.01.40.png" alt="스크린샷 2021-02-21 오후 8.01.40" style="zoom:67%;" />
    - 현재 인덱스 이전의 인덱스들을 돌아보면서 현재 인덱스의 값이 더 크면 나보다 작은 값의 갯수를 담은 dp배열의 해당 인덱스에서 +1을 해주며 모든 값을 비교한다. 그 값들 중 최대를 저장해야하므로 dp[i]에 최대값을 저장하고, 정답으로 반환할 ans에 항상 dp배열의 최대값을 업데이트 해준다.



- 백준 7576 - 토마토
  - 처음 생각했던 풀이
    - 선 종료 조건에 모두 익은상태 / 모두 익을 수 없는 상태를 넣어줌
    - bfs를 이용해서 map에 토마토들을 익게해야하는데 두 가지를 고민해야 했다.
      - 다 익었는지 확인하는 방법 - bfs가 끝나면 자동으로 다 익게 됨.
      - 최소기간을 구하는 방법
        - 첫 번째 시도 - endpoint를 정해서 큐에서 하루치 양만큼 돌면 하루를  지나게 해봄
          - endpoint가 중간에 끊기고 다른 지점에서만 더 bfs가 진행될 경우 카운트 불가 - 실패!
  - 선 종료조건도 잘못이해했어서 한 번 찾아봄
    - 기간을 구하는 방법으로는, 전역변수를 두고 bfs에서 선언한 q에 전역변수를 같이 삽입하면서 하루에 퍼지는 토마토가 같은 cnt값을 가지고 있게해서 기준토마토로부터만 +1 해주면 된다.
    - <img src="/Users/YooDongGwan/Library/Application Support/typora-user-images/스크린샷 2021-02-23 오후 10.55.24.png" alt="스크린샷 2021-02-23 오후 10.55.24" style="zoom: 50%;" />
- 백준 1912 - 연속합
  - 이 문제는 처음에 생각한 방법과 비슷했는데 점점 어렵게 생각해서 산으로 갔다.
  - 경우는 두 가지다.
    - 이전까지의 연속합에 나를 더한게 큰가
    - 나 혼자 있는게 큰가
  - ![스크린샷 2021-02-24 오전 2.39.03](/Users/YooDongGwan/Library/Application Support/typora-user-images/스크린샷 2021-02-24 오전 2.39.03.png)
- 백준 1697 - 숨바꼭질
  - dfs로 풀어야만 하는 문제인 줄 알았는데, 도저히 시도해도 안되서 찾아봤는데 bfs를 이용하여 푸는 문제였다.
  - 트리거
    - 시간을 트리의 깊이라고 생각하고 bfs를 수행하면, 깊이(시간)을 동일하게 1씩 증가시키면서 값이 k가 되는 순간의 깊이를 return 하는 방식으로 구현하면 됨
  - 트러블 슈팅
    - 그래프 탐색 문제라는 생각이 들 경우에는 트리를 생각하고 dfs/bfs 뭐가 더 잘 어울리는지 생각해서 풀자!!!!



- 백준 10844 - 쉬운계단수
  - 풀기전 생각
    - 그냥 세네자리정도까지 다 해보면 갯수에 대한 규칙으로 답이 나올 줄 알았음 - 무식한 생각
    - 근데 내가 제대로 다 생각해내지도 못했었고, 그 방식은 살짝 좋지 않았다
  - ** Dp문제를 무조건 갯수에 대한 문제라고 생각하지 말자
  - 풀이
    - 0-9 라는 숫자에 대한 이해를 하면 규칙을 너무 어렵지 않게 구할 수 있었다. - 일의자리 수가 무엇이느냐에 따라 다음 자리가 늘어났을 때 갯수 예측가능함
    - 0과 9는 1차이나는 수가 1개씩밖에 없고, 1-8은 2개씩 있다. 이 점을 보고 갯수를 어떤식으로 늘려야되는지 판단하고 0과 9의 뒤에 수가 올 때와 1-8까지의 수가 올 때의 차이로 점화식을 찾으면 된다.
    - 이는 dp[ i ] [ j ] 2차원 배열로, i는 몇 자리 수 인지, j는 0-9의 숫자가 들어가는 배열로 이용하여 해결하면 된다.
    - ![스크린샷 2021-02-25 오후 6.01.36](/Users/YooDongGwan/Library/Application Support/typora-user-images/스크린샷 2021-02-25 오후 6.01.36.png)
- 백준 2294 - 동전2
  - 풀이 첫 생각
    - 내림차순으로 정렬해서 큰거부터 계속 빼준다
      - 무조건 틀림--- 이유는 큰거부터 그냥 빼다보면 가능한 것도 불가능해질 수 있음
      - 근데 또 문제를 다시보니 무조건은 아님 - 동전을 몇개든 사용할 수 있으므로
  - 

